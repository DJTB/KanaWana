<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#defaultOptions">defaultOptions</a></li><li><a href="global.html#katakanaToHiragana">katakanaToHiragana</a></li><li><a href="global.html#hiraganaToKatakana">hiraganaToKatakana</a></li><li><a href="global.html#romajiToHiragana">romajiToHiragana</a></li><li><a href="global.html#isMixed">isMixed</a></li><li><a href="global.html#stripOkurigana">stripOkurigana</a></li><li><a href="global.html#bind">bind</a></li><li><a href="global.html#unbind">unbind</a></li><li><a href="global.html#onInput">onInput</a></li><li><a href="global.html#getChunk">getChunk</a></li><li><a href="global.html#getChunkSize">getChunkSize</a></li><li><a href="global.html#isCharUpperCase">isCharUpperCase</a></li><li><a href="global.html#isCharInRange">isCharInRange</a></li><li><a href="global.html#isCharVowel">isCharVowel</a></li><li><a href="global.html#isCharConsonant">isCharConsonant</a></li><li><a href="global.html#isCharLongDash">isCharLongDash</a></li><li><a href="global.html#isCharSlashDot">isCharSlashDot</a></li><li><a href="global.html#isCharKatakana">isCharKatakana</a></li><li><a href="global.html#isCharHiragana">isCharHiragana</a></li><li><a href="global.html#isCharKana">isCharKana</a></li><li><a href="global.html#isCharKanji">isCharKanji</a></li><li><a href="global.html#isCharJapanesePunctuation">isCharJapanesePunctuation</a></li><li><a href="global.html#isCharEnglishPunctuation">isCharEnglishPunctuation</a></li><li><a href="global.html#isCharPunctuation">isCharPunctuation</a></li><li><a href="global.html#convertFullwidthCharsToASCII">convertFullwidthCharsToASCII</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">core.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  HIRAGANA_START,
  KATAKANA_START,
  UPPERCASE_END,
  UPPERCASE_START,
  KANJI_KANA_REGEX,
} from './constants';

import {
  fourCharacterEdgeCases,
  longVowels,
  JtoR,
  RtoJ,
} from './characterTables';

import {
  getChunk,
  getChunkSize,
  isCharLongDash,
  isCharSlashDot,
  isCharConsonant,
  isCharPunctuation,
  isCharHiragana,
  isCharKana,
  isCharKanji,
  isCharInRange,
  isCharKatakana,
  isCharVowel,
  isCharUpperCase,
} from './utils';

/**
  * @typedef DefaultOptions
  * @type {Object}
  * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.
  * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()
  * @property {Boolean} [IMEMode=false] - Set to true to handle input from a text input as it is typed
*/

/**
 * Default config for KanaWana, user passed options will be merged with this
 * @type {DefaultOptions}
 * @example &lt;caption>{ passRomaji: true }&lt;/caption>
 * toHiragana('romaji is not ヒラガナ', {passRomaji: true})
 * // "romaji is not ひらがな"
 */
export const defaultOptions = {
  // Set to true to use obsolete characters, such as ゐ and ゑ.
  useObsoleteKana: false,
  // Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana(),
  // so: "romaji is not ヒラガナ" -> "romaji is not ひらがな"
  passRomaji: false,
  // Set to true to handle input from a text input as it is typed.
  IMEMode: false,
};

/**
 * Convert katakana to hiragana
 * @param  {String} kata text input
 * @return {String} converted text
 */
export function katakanaToHiragana(kata) {
  const hira = [];
  let previousKana = '';
  const iterable = kata.split('');
  for (let index = 0; index &lt; iterable.length; index += 1) {
    const kataChar = iterable[index];
    const [slashDot, longDash] = [isCharSlashDot(kataChar), isCharLongDash(kataChar)];
    // Short circuit to avoid incorrect codeshift for 'ー' and '・'
    if (slashDot || (longDash &amp;&amp; index &lt; 1)) {
      hira.push(kataChar);
    // Transform long vowels: 'オー' to 'おう'
    } else if (longDash &amp;&amp; index > 0) {
      // Transform previousKana back to romaji
      const romaji = hiraganaToRomaji(previousKana).slice(-1);
      hira.push(longVowels[romaji]);
    } else if (isCharKatakana(kataChar)) {
      // Shift charcode.
      const code = kataChar.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);
      const hiraChar = String.fromCharCode(code);
      hira.push(hiraChar);
      previousKana = hiraChar;
    } else {
      // Pass non katakana chars through
      hira.push(kataChar);
      previousKana = '';
    }
  }
  return hira.join('');
}

/**
 * Convert hiragana to katakana
 * @param  {String} hira text input
 * @return {String} converted text
 */
export function hiraganaToKatakana(hira) {
  const kata = [];
  hira.split('').forEach((hiraChar) => {
    // Short circuit to avoid incorrect codeshift for 'ー' and '・'
    if (isCharLongDash(hiraChar) || isCharSlashDot(hiraChar)) {
      kata.push(hiraChar);
    } else if (isCharHiragana(hiraChar)) {
      // Shift charcode.
      const code = hiraChar.charCodeAt(0) + (KATAKANA_START - HIRAGANA_START);
      const kataChar = String.fromCharCode(code);
      kata.push(kataChar);
    } else {
      // Pass non hiragana chars through
      kata.push(hiraChar);
    }
  });
  return kata.join('');
}

/**
 * Convert romaji to hiragana
 * @param  {String} roma text input
 * @param  {Object}
 * @return {String} converted text
 */
export function romajiToHiragana(roma, options = {}) {
  return romajiToKana(roma, options, true);
}

export function isHiragana(input) {
  return [...input].every(isCharHiragana);
}

export function isKatakana(input) {
  return [...input].every(isCharKatakana);
}

export function isKana(input) {
  return [...input].every(isCharKana);
}

export function isRomaji(input) {
  return [...input].every((char) =>
    !isHiragana(char) &amp;&amp; !isKatakana(char) &amp;&amp; !isKanji(char)
  );
}

export function isKanji(input) {
  return [...input].every(isCharKanji);
}

// Test if input is All Japanese, for mixes of kanji and kana like "泣き虫。"
// Includes Japanese full-width punctuation ranges
export function isKanjiKana(input) {
  return [...input].every((char) => KANJI_KANA_REGEX.test(char));
}

/**
 * Test if input is a mix of kana and romaji, defaults to skip kanji
 * @param  {String} input text
 * @param  {Object} [options={ passKanji: true }] optional config to skip over kanji
 * @return {Boolean} true if input is mixed
 */
export function isMixed(input, options = { passKanji: true }) {
  const chars = [...input];
  let hasKanji = false;
  if (!options.passKanji) {
    hasKanji = chars.some(isKanji);
  }
  return (chars.some(isHiragana) || chars.some(isKatakana)) &amp;&amp; chars.some(isRomaji) &amp;&amp; !hasKanji;
}

export function toHiragana(input, options = {}) {
  const config = Object.assign({}, defaultOptions, options);
  if (config.passRomaji) return katakanaToHiragana(input);
  if (isRomaji(input)) return romajiToHiragana(input, config);
  if (isMixed(input, { passKanji: true })) {
    const romaji = katakanaToHiragana(input);
    return romajiToHiragana(romaji, config);
  }
  return katakanaToHiragana(input);
}

export function toKatakana(input, options = {}) {
  const config = Object.assign({}, defaultOptions, options);
  if (config.passRomaji) return hiraganaToKatakana(input);
  if (isRomaji(input) || isMixed(input)) {
    const romaji = romajiToHiragana(input, config);
    return hiraganaToKatakana(romaji);
  }
  return hiraganaToKatakana(input);
}

export function toKana(input, options) {
  return romajiToKana(input, options);
}

export function toRomaji(input, options) {
  return hiraganaToRomaji(input, options);
}

function hiraganaToRomaji(hira, options = {}) {
  // merge options with default options
  const config = Object.assign({}, defaultOptions, options);
  const len = hira.length;
  // Final output array
  const roma = [];
  // Position in the string that is being evaluated
  let cursor = 0;
  const maxChunk = 2;
  let chunkSize = 2;
  let chunk = '';
  let romaChar = '';
  let nextCharIsDoubleConsonant;

  while (cursor &lt; len) {
    chunkSize = getChunkSize(maxChunk, len - cursor);
    let convertThisChunkToUppercase = false;
    while (chunkSize > 0) {
      chunk = getChunk(hira, cursor, cursor + chunkSize);
      if (isKatakana(chunk)) {
        convertThisChunkToUppercase = config.convertKatakanaToUppercase;
        chunk = katakanaToHiragana(chunk);
      }
      // special case for small tsus
      if (chunk.charAt(0) === 'っ' &amp;&amp; chunkSize === 1 &amp;&amp; cursor &lt; (len - 1)) {
        nextCharIsDoubleConsonant = true;
        romaChar = '';
        break;
      }

      romaChar = JtoR[chunk];

      if ((romaChar != null) &amp;&amp; nextCharIsDoubleConsonant) {
        romaChar = romaChar.charAt(0).concat(romaChar);
        nextCharIsDoubleConsonant = false;
      }
      // console.log(`${cursor}x${chunkSize}:${chunk} => ${romaChar}`);
      if (romaChar != null) {
        break;
      }
      chunkSize -= 1;
    }
    if (romaChar == null) {
      // Passthrough undefined values
      romaChar = chunk;
    }

    if (convertThisChunkToUppercase) {
      romaChar = romaChar.toUpperCase();
    }
    roma.push(romaChar);
    cursor += chunkSize || 1;
  }

  return roma.join('');
}

export function romajiToKana(roma, options = {}, ignoreCase = false) {
  const config = Object.assign({}, defaultOptions, options);
  // Final output array
  const kana = [];
  // Position in the string that is being evaluated
  let cursor = 0;
  const len = roma.length;
  const maxChunk = 3;
  let chunkSize = 3;
  let chunk = '';
  let chunkLC = '';

  // Steps through the string pulling out chunks of characters. Each chunk will be evaluated
  // against the romaji to kana table. If there is no match, the last character in the chunk
  // is dropped and the chunk is reevaluated. If nothing matches, the character is assumed
  // to be invalid or punctuation or other and gets passed through.
  while (cursor &lt; len) {
    let kanaChar = null;
    chunkSize = getChunkSize(maxChunk, len - cursor);
    while (chunkSize > 0) {
      chunk = getChunk(roma, cursor, cursor + chunkSize);
      chunkLC = chunk.toLowerCase();
      // Handle super-rare edge cases with 4 char chunks (like ltsu, chya, shya)
      if (fourCharacterEdgeCases.includes(chunkLC) &amp;&amp; (len - cursor) >= 4) {
        chunkSize += 1;
        chunk = getChunk(roma, cursor, cursor + chunkSize);
        chunkLC = chunk.toLowerCase();
      } else {
        // Handle edge case of n followed by consonant
        if (chunkLC.charAt(0) === 'n') {
          if (chunkSize === 2) {
            // Handle edge case of n followed by a space (only if not in IME mode)
            if (!config.IMEMode &amp;&amp; chunkLC.charAt(1) === ' ') {
              kanaChar = 'ん ';
              break;
            }
            // Convert IME input of n' to "ん"
            if (config.IMEMode &amp;&amp; chunkLC === "n'") {
              kanaChar = 'ん';
              break;
            }
          }
          // Handle edge case of n followed by n and vowel
          if (isCharConsonant(chunkLC.charAt(1), false) &amp;&amp; isCharVowel(chunkLC.charAt(2))) {
            chunkSize = 1;
            chunk = getChunk(roma, cursor, cursor + chunkSize);
            chunkLC = chunk.toLowerCase();
          }
        }

        // Handle case of double consonants
        if (chunkLC.charAt(0) !== 'n' &amp;&amp;
          isCharConsonant(chunkLC.charAt(0)) &amp;&amp;
          chunk.charAt(0) === chunk.charAt(1)
        ) {
          chunkSize = 1;
          // Return katakana ッ if chunk is uppercase, otherwise return hiragana っ
          if (isCharInRange(chunk.charAt(0), UPPERCASE_START, UPPERCASE_END)) {
            chunkLC = chunk = 'ッ';
          } else {
            chunkLC = chunk = 'っ';
          }
        }
      }

      kanaChar = RtoJ[chunkLC];
      // console.log(`${cursor}x${chunkSize}:${chunk} => ${kanaChar}`); // DEBUG
      if (kanaChar != null) {
        break;
      }
      // Step down the chunk size.
      // If chunkSize was 4, step down twice.
      if (chunkSize === 4) {
        chunkSize -= 2;
      } else {
        chunkSize -= 1;
      }
    }

    // Passthrough undefined values
    if (kanaChar == null) {
      kanaChar = chunk;
    }

    // Handle special cases.
    if (config.useObsoleteKana) {
      if (chunkLC === 'wi') kanaChar = 'ゐ';
      if (chunkLC === 'we') kanaChar = 'ゑ';
    }

    if (!!config.IMEMode &amp;&amp; chunkLC.charAt(0) === 'n') {
      if ((roma.charAt(cursor + 1).toLowerCase() === 'y' &amp;&amp;
        isCharVowel(roma.charAt(cursor + 2)) === false) ||
        cursor === (len - 1) ||
        isKana(roma.charAt(cursor + 1))
      ) {
        // Don't transliterate this yet.
        kanaChar = chunk.charAt(0);
      }
    }

    // Use katakana if first letter in chunk is uppercase
    if (!ignoreCase) {
      if (isCharUpperCase(chunk.charAt(0))) {
        kanaChar = hiraganaToKatakana(kanaChar);
      }
    }

    kana.push(kanaChar);
    cursor += chunkSize || 1;
  }

  return kana.join('');
}

/**
 * Strips trailing okurigana if input is a mix of kanji and kana
 * @param  {String} input text to parse
 * @param  {Object} [options={ all: false }] config object specifying if *all* kana should be removed
 * @return {String} string new string with trailing okurigana removed
 */
export function stripOkurigana(input, options = { all: false }) {
  if (!isKanjiKana(input) || isKana(input)) return input;
  const chars = [...input];

  // strip every kana
  if (options.all) return chars.filter((char) => !isCharKana(char)).join('');

  // strip trailing only
  const reverseChars = chars.reverse();
  for (let i = 0, len = reverseChars.length; i &lt; len; i += 1) {
    const char = reverseChars[i];
    // pass if it's punctuation
    if (isCharPunctuation(char)) continue; // eslint-disable-line no-continue
    // blank out if not kanji
    if (!isKanji(char)) {
      reverseChars[i] = '';
    } else break; // stop when we hit a kanji char
  }

  return reverseChars.reverse().join('');
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun Jan 01 2017 22:50:33 GMT+0700 (ICT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
